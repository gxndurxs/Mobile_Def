# Практическая работа №4
**Тема:** Привязка компонентов интерфейса, асинхронные процессы, сервисы и фоновые задачи с WorkManager в Android.  
**Цель:**
Освоить следующие техники:
- использование ViewBinding для связи элементов интерфейса с кодом;
- реализация многопоточной работы с помощью Thread, Handler, Looper, Loader;
- обмен информацией между потоками и обновление UI из фона;
- создание сервиса (Service) для воспроизведения аудио;
- выполнение фоновых задач через WorkManager.
## Основной проект
Был создан проект **ru.mirea.ostrovskiy.lesson4**, В файле build.gradle модуля была активирована функция viewBinding.
Для каждого XML-файла разметки был автоматически сгенерирован соответствующий класс привязки (например, ActivityMainBinding).
В MainActivity инициализация класса привязки была выполнена с помощью статического метода inflate.
Доступ к UI-элементам (таким как Button и TextView) осуществлялся через экземпляр класса привязки, что обеспечило типобезопасность и защиту от null-ссылок.
Было создано два макета для экрана музыкального плеера: один для портретной и один для альбомной ориентации, чтобы продемонстрировать работу View Binding с разными конфигурациями экрана.

## Асинхронная работа: основы
В рамках модуля thread была реализована простая многопоточная структура.
Использование ViewBinding заменяет вызов findViewById, позволяет безопасно обращаться к компонентам и избавляет от NullPointerException.
Создание вторичных потоков через Thread позволяет выносить тяжёлые операции за пределы UI-потока.
Для взаимодействия с главным потоком использовался runOnUiThread(), который позволяет обновить интерфейс из фонового потока безопасно и корректно.

## Передача данных между потоками 
### Задание 3.1 – 3.3
В модуле data_thread реализован обмен информацией между потоками с применением Looper и Handler.
Была настроена очередь сообщений, в которой данные (вводимые пользователем возраст и профессия, в моем случае: 20 лет, стажер Альфа-Банк) передаются во второй поток, где выполняется задержка, соответствующая возрасту. После этого результат возвращается в основной поток и отображается в интерфейсе.
Также применялись методы:
- runOnUiThread(Runnable) — немедленное выполнение задачи в UI-потоке;
- View.post(Runnable) — добавление задачи в очередь сообщений;
- View.postDelayed(Runnable, delay) — запуск с задержкой.

## Loader и работа с шифрованием
В модуле CryptoLoader создан собственный загрузчик MyLoader, наследующий AsyncTaskLoader<String>.
В конструктор передавались Context и Bundle, содержащий зашифрованный текст и ключ.
Загрузка и дешифровка выполнялись в loadInBackground() с использованием утилит CryptoUtils.

## Сервис и воспроизведение музыки
В модуле ServiceApp реализован компонент Service, работающий в фоновом режиме.
Сервис позволяет запускать аудиотрек в фоне, даже если пользователь покидает экран.
В интерфейсе отображается уведомление, информирующее о проигрывании.
Это пример foreground service, который корректно управляется системой и сохраняется при смене состояний активности.

## Работа с WorkManager
Модуль WorkManagerApp подключён через зависимости в build.gradle.
Создана одноразовая задача (OneTimeWorkRequest), демонстрирующая:
- выполнение действия в фоновом режиме;
- установку ограничений на выполнение (например, при наличии сети);
- отмену задачи, если условия не соблюдаются;
- автоматическое управление системой даже в режимах Doze и JobScheduler.

## Результаты работы
В результате выполнения практической части были освоены:
- технологии ViewBinding для привязки компонентов;
- принципы многопоточной архитектуры (Thread, Handler, Looper);
- создание взаимодействия между фоновыми и основными потоками;
- реализация пользовательского сервиса для проигрывания медиа;
- запуск и управление задачами с помощью WorkManager.
# Интеграция с MireaProject
В учебный проект **MireaProject** был добавлен новый компонент — WorkFragment, реализующий запуск фоновой задачи через WorkManager.
После нажатия на кнопку начинается выполнение работы в отдельном потоке с задержкой, а статус отображается прямо в интерфейсе.
Такой подход помогает организовать длительные или отложенные действия без нагрузки на основной процесс приложения.


---

**Работу выполнил**:Островский А.И 
**Группа**: БСБО-09-22







